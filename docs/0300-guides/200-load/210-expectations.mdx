---
title: "Data Quality Expectations â€” Post-Load Assertions in Starlake"
description: "Define post-load data quality expectations in Starlake using Jinja SQL macros. Assert uniqueness, row counts and custom conditions on target tables with failOnError support."
keywords: [starlake, expectations, data quality, assertions, validation, post-load checks, Jinja, SQL, failOnError]
---

import Head from '@docusaurus/Head';

<Head>
  <script type="application/ld+json">
    {JSON.stringify({
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "What is an expectation in Starlake?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "An expectation is an assertion executed after data loading. It consists of a SQL query evaluated on the target table, whose result is compared to an expected condition."
          }
        },
        {
          "@type": "Question",
          "name": "How do I define an expectation in the table YAML file?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Add an expectations section with a list of entries. Each entry contains expect (query name + condition) and optionally failOnError: true to halt the pipeline on failure."
          }
        },
        {
          "@type": "Question",
          "name": "What is the format of an expectation expression?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "The format is <query_name>(<params>) => <condition>. The query_name references a Jinja template defined in the expectations directory. The condition uses the variables count, result or results."
          }
        },
        {
          "@type": "Question",
          "name": "How do I write an expectation query template?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Templates are Jinja2 macros with a .j2 extension placed in the expectations directory. They generate SQL. The SL_THIS placeholder represents the target table."
          }
        },
        {
          "@type": "Question",
          "name": "What variables are available in an expectation condition?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Three variables: count (number of rows in the result), result (first row as a collection of values), and results (all rows as a collection of collections)."
          }
        },
        {
          "@type": "Question",
          "name": "Can I stop the pipeline if an expectation fails?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes. Set failOnError: true on the expectation. If the condition is not satisfied, the pipeline halts with an error."
          }
        },
        {
          "@type": "Question",
          "name": "What built-in expectation macros does Starlake provide?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Starlake documents: is_col_value_not_unique, is_row_count_to_be_between, col_value_count_greater_than, count_by_value and column_occurs. They are customizable and extensible."
          }
        }
      ]
    })}
  </script>
  <script type="application/ld+json">
    {JSON.stringify({
      "@context": "https://schema.org",
      "@type": "HowTo",
      "name": "How to add data quality expectations in Starlake",
      "description": "Define post-load assertions using Jinja SQL macros to validate data quality during ingestion.",
      "step": [
        {
          "@type": "HowToStep",
          "name": "Create or reuse an expectation macro",
          "text": "Place a .j2 Jinja2 template in the expectations directory. Use SL_THIS as a placeholder for the target table name."
        },
        {
          "@type": "HowToStep",
          "name": "Open the table YAML file",
          "text": "Edit metadata/load/<domain>/<table>.sl.yml."
        },
        {
          "@type": "HowToStep",
          "name": "Add an expectations section",
          "text": "Under the table key, define a list of expectation entries."
        },
        {
          "@type": "HowToStep",
          "name": "Write the expectation expression",
          "text": "Use the format <query_name>(<params>) => <condition>. Available condition variables are count, result and results."
        },
        {
          "@type": "HowToStep",
          "name": "Set failOnError",
          "text": "Set to true to halt the pipeline on failure, or false to log and continue."
        },
        {
          "@type": "HowToStep",
          "name": "Run the load",
          "text": "Execute starlake load. Expectations are evaluated after the data has been written to the target table."
        }
      ]
    })}
  </script>
</Head>

# Expectations

Starlake expectations are post-load assertions that validate the data written to the target table. Each expectation references a Jinja2 SQL macro, passes parameters and evaluates a condition on the query result. You can halt the pipeline on failure with `failOnError: true`, making expectations a lightweight data quality gate built into the ingestion process.

## How to add data quality expectations

1. **Create or reuse an expectation macro** -- Place a `.j2` Jinja2 template in the `expectations` directory. Use `SL_THIS` as a placeholder for the target table name.
2. **Open the table YAML file** -- Edit `metadata/load/<domain>/<table>.sl.yml`.
3. **Add an `expectations` section** -- Under the `table` key, define a list of entries.
4. **Write the expectation expression** -- Use the format `<query_name>(<params>) => <condition>`. Available condition variables are `count`, `result` and `results`.
5. **Set `failOnError`** -- Set to `true` to halt the pipeline on failure, or `false` to log and continue.
6. **Run the load** -- Execute `starlake load`. Expectations are evaluated after the data has been written.

Expectations allow to test if the resulting table contains the expected data.

They are defined using the `expectations` attribute as follows:

```yaml

table:
    ...
    attributes:
        - name: id
          type: integer
        ...
    expectations:
      - expect: "is_col_value_not_unique('id') => result(0) == 1"
        failOnError: true # or false if you want to continue

```

The `expectations` attribute is a list of strings, each string representing an expectation. The expectation is defined as a string with the following format:

```
<query_name>(<param>*) => <condition>
```

`<query_name>` is the name of the expectation to be tested. The available expectations are defined in the `expectations` directory. An query is a SELECT statement run against the target table and the result is used to test the expectation.

`<param>` is the parameter to be passed to the expectation. It is a value that can be read as the expected type by the expectation. Parameters are separated by commas.

`<condition>` is the condition to be tested. It is a string that can be parsed to a boolean by the expectation and that will be used to test the expectation:

The following variables are available in the condition:

|Variable|Type|Description
|---|---|---
count|Long|The number of rows in the result
result|Seq[Any]|The first row in the result as a collection of values (one per column)
results|Seq[Seq[Any]]|The result as a collection of rows, each row as a collection of values (one per column)

## Writing expectation queries

Expectation queries are mainly jinja macro templates that are used to generate SQL queries.

```jinja
{% macro is_col_value_not_unique(col, table='SL_THIS') %}
    SELECT max(cnt)
    FROM (SELECT {{ col }}, count(*) as cnt FROM {{ table }}
    GROUP BY {{ col }}
    HAVING cnt > 1)
{% endmacro %}

{% macro is_row_count_to_be_between(min_value, max_value, table_name = 'SL_THIS') -%}
    select
        case
            when count(*) between {{min_value}} and {{max_value}} then 1
        else
            0
        end
    from {{table_name}}
{%- endmacro %}

{% macro col_value_count_greater_than(col, min_count, table_name='SL_THIS') %}
    SELECT {{ col }}, count(*) FROM {{ table_name }}
    GROUP BY {{ col }}
    HAVING count(*) > {{ min_count }}
{% endmacro %}


{% macro count_by_value(col, value, table='SL_THIS') %}
    SELECT count(*)
    FROM {{ table }}
    WHERE {{ col }} LIKE '{{ value }}'
{% endmacro %}


{% macro column_occurs(col, times, table='SL_THIS') %}
    SELECT max(cnt)
    FROM  (
        SELECT {{ col }}, count(*) as cnt FROM {{ table }}
        GROUP BY {{ col }}
        HAVING cnt == {{ times }}
    )
{% endmacro %}
```


Put the queries in the `expectations` directory and use the `.j2` extension.
You may organize your queries in subdirectories.

## Frequently Asked Questions

### What is an expectation in Starlake?
An expectation is a post-load assertion executed after data loading. It consists of a SQL query evaluated on the target table, whose result is compared to an expected condition.

### How do I define an expectation in the table YAML file?
Add an `expectations` section with a list of entries. Each entry contains `expect` (query name + condition) and optionally `failOnError: true` to halt the pipeline on failure.

### What is the format of an expectation expression?
The format is `<query_name>(<params>) => <condition>`. The `query_name` references a Jinja template defined in the `expectations` directory. The condition uses the variables `count`, `result` or `results`.

### How do I write an expectation query template?
Templates are Jinja2 macros with a `.j2` extension placed in the `expectations` directory. They generate SQL. The `SL_THIS` placeholder represents the target table.

### What variables are available in an expectation condition?
Three variables: `count` (number of rows in the result), `result` (first row as a collection of values), and `results` (all rows as a collection of collections).

### Can I stop the pipeline if an expectation fails?
Yes. Set `failOnError: true` on the expectation. If the condition is not satisfied, the pipeline halts with an error.

### What built-in expectation macros does Starlake provide?
Starlake documents: `is_col_value_not_unique`, `is_row_count_to_be_between`, `col_value_count_greater_than`, `count_by_value` and `column_occurs`. They are customizable and extensible.

